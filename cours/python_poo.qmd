---
title: "Gentle introduction √† la Programmation Orient√©e Objets en Python"
subtitle: "Tu exploreras les concepts fondamentaux comme les classes, les objets, l'encapsulation et l'h√©ritage, tout en apprenant √† les appliquer √† des exemples concrets."
format: 
    html:
        toc: true
        toc_float: true
        toc-title: Table des mati√®res
        toc-location: left
        code-copy: true
        code-fold: false
        code-link: true
        code-overflow: scroll
        code-summary: "Voir le code"
        embed-resources: true
        anchor-sections: true
        smooth-scroll: true
number-sections: true
execute: 
    echo: true
    warning: false
    message: false
    fig.with: 9
title-block-banner: "#fff"
title-block-banner-color: "black"
author: M√©nyssa Cherifa-Luron, PhD
date: today
---

#  Contexte et notions √©l√©mentaires

## La Programmation orient√©e objet   
La Programmation Orient√©e Objet (POO), c'est la base de la base, le flow de la programmation !

En POO, **une classe c'est comme un moule √† objets**, une repr√©sentation qui d√©finit les caract√©ristiques et les comportements des entit√©s du m√™me type.

Et un **objet** ? **C'est une instance unique cr√©√©e √† partir de ce moule**, comme un rappeur qui sort du lot !

Tout comme un rappeur a ses propres caract√©ristiques (son flow, son style, ses punchlines...), **un objet a ses propres attributs (des variables) et m√©thodes (des fonctions).**

<div style="text-align: center;">
  <img src="../images/car_class.png" alt="OOP car class" style="width: 400px;">
  <p><em> Fig 1. Imagine une voiture en tant que classe, avec des attributs principaux tels que le mod√®le, le prix, la couleur et l'ann√©e de construction. Tu peux cr√©er autant d‚Äôobjets que tu le souhaites √† partir de la classe.</em></p>
</div>

En Python, tout est objet, m√™me les classes ! C'est dire si √ßa a de la classe.

Pour acc√©der aux attributs d'un objet, on utilise la notation **"dot"**, comme quand on dit *"tel rappeur.son flow"*, tu vois le style ?

Et pour cr√©er une instance √† partir d'une classe, c'est comme si tu lan√ßais un nouveau rappeur dans le game ! Tu utilises le constructeur de la classe.

Bref, la POO c'est le swag de la programmation ! √áa structure ton code comme un bon album, avec chaque classe qui joue son r√¥le.

Alors, t'es chaud pour devenir une OOP star ?
On va coder √ßa comme jamais ! 

## Avantages

Les avantages de ce style de programmation, c'est comme les atouts d'un bon rappeur :

> **Un flow r√©utilisable et partageable üé§**
Avec la POO, ton code est comme un bon couplet : 
Tu peux le r√©utiliser et le partager sans tout r√©√©crire √† chaque fois !

> **Une s√©curit√© renforc√©e üîí**
La POO, c'est comme un bon contrat de label : 
Tu prot√®ges tes donn√©es sensibles pour √©viter les leaks !

> **Un debugging facilit√© üêõ**
Avec la POO, quand y'a un bug, c'est comme chercher la fausse note : 
Tu sais direct dans quelle mesure chercher !

> **Une flexibilit√© de ouf üöÄ**
La POO, c'est comme un featuring qui d√©chire : 
Tu peux r√©utiliser les talents de plusieurs classes sans r√©inventer la roue !

**Les mots cl√©s de la POO**, c'est comme le flow, les punchlines, les phases et les mesures pour un rappeur : 
**Classe, Objet, M√©thodes et Attributs, c'est les bases pour rapper de la bonne POO !**

Et les **4 concepts fondamentaux**, c'est comme les 4 √©l√©ments du hip-hop :

1. **H√©ritage**

2. **Encapsulation**

3. **Polymorphisme** 

4. **Abstraction**

C'est ce qui fait toute la richesse de la POO !

::: {.callout-important collapse=false}
## √Ä Retenir

En somme, la POO, c'est plus modulaire qu'un beat et plus r√©utilisable qu'un sample. Elle permet :
<ul>
    <li>Modularit√© et r√©utilisabilit√© du code</li>
    <li>Facilit√© de maintenance et d'√©volution du code</li>
    <li>Repr√©sentation naturelle des concepts du monde r√©el</li>
</ul>
:::

## Classe

**Une classe, c'est comme un moule √† g√¢teau en forme de rappeur** :

Elle d√©finit les caract√©ristiques et les comportements - comme un rappeur a son style, son flow, ses punchlines.

Concr√®tement, une classe c'est un *blueprint*, un mod√®le qui va servir √† cr√©er des objets.

C'est un peu comme un label de musique qui a son identit√© et qui va signer des artistes qui correspondent √† son style.

**Quand tu cr√©es un objet √† partir de cette classe, on dit que tu cr√©es une instance**. 

> Une instance est un exemplaire unique de cette classe !

Un peu comme un rappeur sign√© sur le label, qui a son style propre tout en s'inscrivant dans l'identit√© du label.

Et le gros avantage, c'est que **tu peux cr√©er autant d'instances que tu veux √† partir de la m√™me classe** !

C'est comme si ton label pouvait signer des dizaines de rappeurs qui ont chacun leur personnalit√© mais qui repr√©sentent tous l'esprit du label.

Bref, les classes c'est la base de la POO et c'est ce qui va te permettre de structurer ton code de fa√ßon claire et r√©utilisable.

```{python}
# D√©finition basique de la classe Rappeur
class Rappeur: 
    pass

# D√©finition de l'instance unique menyssa
menyssa = Rappeur()  

# menyssa est bien un objet Rappeur
type(menyssa) 
```

::: {.callout-caution}
### Le terme `__main__` 

Le terme `__main__` dans Python a une signification sp√©ciale. Il fait r√©f√©rence au nom de l'espace de noms (ou du "scope") dans lequel le script courant est ex√©cut√©. 

C'est une mani√®re pour Python de savoir si le fichier actuel est ex√©cut√© comme script principal ou s'il est import√© √† partir d'un autre fichier.*

:::

## Constructeur : `__init__` et  `self`
Le constructeur `__init__` est **appel√© automatiquement quand tu cr√©es une nouvelle instance de ta classe.**

Son r√¥le ? 

**Initialiser les attributs de ton objet**, comme un Directeur Artistique (DA) qui d√©finirait le style et l'image de son artiste.

Et `self` dans tout √ßa ? **C'est le rappeur lui-m√™me !** 

Dans une m√©thode, `self` fait r√©f√©rence √† l'instance courante de la classe. **C'est gr√¢ce √† lui que tu peux acc√©der aux attributs et m√©thodes de ton objet.**

Quand tu appelles une m√©thode sur une instance, Python passe automatiquement cette instance en premier argument. 
C'est pour √ßa que tu retrouves `self` partout !

::: {.callout-important collapse=false}
## √Ä Retenir

<code>__init__ et self</code>, permettent de construire et de faire vivre tes objets, comme un DA et son rappeur qui cr√©ent ensemble un personnage unique. :
<ul>
  <li><code>__init__</code> est le constructeur qui initialise les attributs</li>
  <li><code>self</code> repr√©sente l'instance courante dans les m√©thodes</li>
  <li> Ensemble, ils donnent vie √† tes objets et leur permettent d'interagir avec le monde !</li>
</ul>
:::

## Attributs 

Les attributs en POO, c'est comme les **caract√©ristiques qui d√©finissent un bon rappeur.**

Par exemple pour chaque rappeur on peut lui attribu√© les caract√©ristiques suivantes : 

1. **Le flow (self.flow)** : c'est son d√©bit, sa mani√®re de rapper. √áa peut √™tre smooth, agressif, technique... C'est ce qui fait son style unique.

2. **Le nombre d'albums (self.nb_albums)** : √ßa montre son exp√©rience, comme le nombre de projets sur GitHub pour un dev. Plus t'en as, plus t'es respect√© !

3. **Les featuring (self.featurings)** : c'est les collab avec d'autres artistes. Comme quand tu fais du pair programming ou que tu participes √† un projet open source.

Voici comment d√©clarer ces attributs dans notre classe "Rappeur" 

```{python}
# D√©finition de la classe Rappeur 
class Rappeur:
    # Constructeur de la classe avec les attributs
    def __init__(self, nom, flow, nb_albums, featurings):
        self.nom = nom              # Nom du rappeur
        self.flow = flow            # Style de flow musical du rappeur
        self.nb_albums = nb_albums  # Nombre total d'albums produits
        self.featurings = featurings  # Liste des artistes avec lesquels il a collabor√©

# Cr√©ation des instances de la classe Rappeur pour Booba, Vald et Niska.
# Chaque instance est cr√©√©e avec des d√©tails sp√©cifiques au rappeur.
booba = Rappeur(nom="Booba", 
                flow="Agressif et technique",                
                nb_albums=10,
                featurings=["Kaaris", "Damso", "Gato"])

vald = Rappeur(nom="Vald",
               flow="Sombre et introspectif",
               nb_albums=6,
               featurings=["Suikon Blaz AD", "Damso"])

niska = Rappeur(nom="Niska", 
                flow="M√©lodique et festif", 
                nb_albums=4, 
                featurings=["Booba", "SCH", "Hamza"])

# Ici, on affiche le nombre d'albums produits par Niska et le style de Booba.
print(f"Niska a produit {niska.nb_albums} albums et \n"
      f"le flow de Booba est : {booba.flow}")

# Ici, on affiche le flow de vald et son nombre d'album.
print(f"\nVald a produit {vald.nb_albums} albums et son flow est {vald.flow.lower()}")
```

## M√©thodes

Les m√©thodes, c'est ce qui **permet √† tes objets d'agir, d'interagir et de se d√©marquer.** 

Une m√©thode peut √™tre :

- Un flow "getter" pour r√©cup√©rer des infos (`get_punchline()`)
- Un flow "setter" pour modifier l'√©tat (`set_style(new_style)`) 
- Un flow "calculateur" pour traiter des donn√©es (`calculer_nb_albums()`)
- Ou m√™me un flow "abstract" pour d√©finir un comportement g√©n√©ral (`rapper()`)

Les m√©thodes, c'est aussi ce qui permet √† tes **objets de communiquer entre eux.** 
Un peu comme des featuring entre rappeurs !

```{python}
# Importation du module random
import random

# D√©finition de la classe Rappeur
class Rappeur:
    # Constructeur de la classe avec les attributs n√©cessaires pour d√©finir un rappeur
    def __init__(self, nom, flow, nb_albums, featurings, punchlines):
        self.nom = nom              
        self.flow = flow            
        self.nb_albums = nb_albums  
        self.featurings = featurings  
        self.punchlines = punchlines  # Liste des punchlines c√©l√®bres du rappeur
    
    # M√©thode pour afficher une punchline au hasard
    def balancer_punchline(self):
        # Utilisation de random.choice pour s√©lectionner et afficher une punchline al√©atoire de la liste
        print(f"{self.nom} balance : {random.choice(self.punchlines)}")

# Cr√©ation d'une instance Booba
booba = Rappeur(nom="Booba", 
                flow="Agressif et technique",                
                nb_albums=10,
                featurings=["Kaaris", "Damso", "Gato"],
                punchlines=["92i", "Pitbull", "Kalash"])

# Appel de la m√©thode balancer_punchline pour afficher une punchline de Booba tir√©e au hasard
booba.balancer_punchline()
```

Maintenant allons un peu plus long et imaginons un clash entre rappeurs (*hihihi!*)

```{python}
import random  # Importation n√©cessaire pour utiliser random.choice

class Rappeur:
    def __init__(self, nom, flow, nb_albums, featurings, punchlines):
        self.nom = nom  
        self.flow = flow  
        self.nb_albums = nb_albums  
        self.featurings = featurings  
        self.punchlines = punchlines  


    def balancer_punchline(self):
        print(f"{self.nom} balance : {random.choice(self.punchlines)}")

    # M√©thode permettant √† un rappeur de clasher un autre rappeur 
    # en utilisant la premi√®re punchline de sa liste
    def clasher(self, autre_rappeur):
        print(f"{self.nom} clash {autre_rappeur.nom} : {self.punchlines[0]}")
        
    # M√©thode permettant √† un rappeur de r√©pondre √† un 
    # clash avec une punchline sp√©cifique
    def repondre(self, autre_rappeur, punchline):
        print(f"{self.nom} r√©pond √† {autre_rappeur.nom} : {punchline}")

# Cr√©ation des instances pour Booba et Kaaris
booba = Rappeur(nom="Booba", 
                flow="Agressif et technique",                
                nb_albums=10,
                featurings=["Kaaris", "Damso", "Gato"],
                punchlines=["T'es qu'un fils de...", "J'vais t'faire une Kalash en live"])        

kaaris = Rappeur(nom="Kaaris",
                 flow="Aggressif et sombre",
                 nb_albums=8,
                 featurings=["Gazo", "Kalash Criminel", "Hamza"],
                 punchlines=["J'vais t'faire danser la Zumba", "T'es m√™me pas un vrai MC"])

# Simulation d'un clash entre Booba et Kaaris
booba.clasher(kaaris)
kaaris.repondre(booba, "T'es qu'un tocard !")
booba.repondre(kaaris, "TG ! J'suis le DUC !")
```

La puissance des attributs et des m√©thodes r√©sident dans l'int√©raction de tes objets de mani√®re intuitive et ***styl√©e.***

::: {.callout-important collapse=false}
## √Ä Retenir

les attributs et m√©thodes c'est ce qui donne vie √† tes objets et leur permet de briller sur la sc√®ne de ton programme !

Alors pour cr√©er des m√©thodes qui claquent, suis ces tips :
<ul>
  <li>Donne-leur un nom explicite qui d√©crit bien leur r√¥le</li>
  <li>Utilise le `self` pour acc√©der aux attributs et autres m√©thodes de l'objet</li>
  <li>S√©pare bien les responsabilit√©s : une m√©thode = une t√¢che pr√©cise</li>
  <li>Documente-les avec des docstrings pour expliquer ce qu'elles font</li>
  <li>La PEP 8 est ton ami !</li>
</ul>
:::

::: {.callout-tip appearance="simple" collapse="true"}
### Focus : PEP8 et Annotation de type 

Voici la m√™me classe avec le **code PEP 8 friendly** et  les annotations de type
```{python}
from typing import List # annoter les attributs featurings et punchlines.
import random
class Rappeur:
    """Classe d√©finissant un rappeur caract√©ris√© par son nom, style de flow, nombre 
    d'albums, collaborations et punchlines.
    """
    def __init__(self, nom: str, flow: str, nb_albums: int, featurings: List[str], 
                 punchlines: List[str]):
        self.nom: str = nom
        self.flow: str = flow
        self.nb_albums: int = nb_albums
        self.featurings: List[str] = featurings
        self.punchlines: List[str] = punchlines

    def balancer_punchline(self) -> None:
        """Affiche une punchline al√©atoire du rappeur."""
        punchline: str = random.choice(self.punchlines)
        print(f"{self.nom} balance : {punchline}")

    def clasher(self, autre_rappeur: 'Rappeur') -> None:
        """Permet au rappeur de clasher un autre rappeur en utilisant la premi√®re 
        punchline de sa liste.
        """
        print(f"{self.nom} clash {autre_rappeur.nom} : {self.punchlines[0]}")
        
    def repondre(self, autre_rappeur: 'Rappeur', punchline: str) -> None:
        """Permet au rappeur de r√©pondre √† un clash avec une punchline sp√©cifique."""
        print(f"{self.nom} r√©pond √† {autre_rappeur.nom} : {punchline}")

# Cr√©ation d'instances pour Booba et Kaaris avec typage explicite
booba = Rappeur(
    nom="Booba", 
    flow="Agressif et technique",                
    nb_albums=10,
    featurings=["Kaaris", "Damso", "Gato"],
    punchlines=["T'es qu'un fils de...", "J'vais t'faire une Kalash en live"]
)        

kaaris = Rappeur(
    nom="Kaaris",
    flow="Aggressif et sombre",
    nb_albums=8,
    featurings=["Gazo", "Kalash Criminel", "Hamza"],
    punchlines=["J'vais t'faire danser la Zumba", "T'es m√™me pas un vrai MC"]
)

# Simulation d'un clash et r√©ponses entre Booba et Kaaris
booba.clasher(kaaris)
kaaris.repondre(booba, "T'es qu'un tocard !")
booba.repondre(kaaris, "TG ! J'suis le DUC !")
```
:::

## Modifier les attributs

C'est essentiel pour g√©rer les interactions entre objets,**contr√¥ler l'acc√®s aux donn√©es et rendre le code plus lisible**, comme un rappeur qui adapte son flow √† diff√©rents beats pour cr√©er des sons uniques et puissants. üé§üí™

Comme vu pr√©c√©demment, pour chaque instance de `Rappeur`, tu peux acc√©der √† ses attributs directement 

```{python}
print(booba.nom)  
print(booba.flow) 
```
Pour modifier les attributs, tu assignes simplement une nouvelle valeur. 

Par exemple, si tu veux changer le flow de Booba 

```{python}
booba.flow = "Lyrique et complexe"
print(booba.flow)
```

Si tu veux changer une punchline sp√©cifique ou en ajouter une nouvelle 
```{python}
booba.punchlines[0] = "Nouvelle punchline plus forte"
booba.punchlines.append("Tout le monde sait que j'suis le meilleur")  
```

Il est souvent *plus* judicieux de contr√¥ler la modification des attributs via des m√©thodes au lieu de les modifier directement. Cela offre une meilleure **encapsulation** (notion que nous verrons apr√®s). 

Tu pourrais ajouter une m√©thode comme `changer_flow()` directement dans ta classe Rappeur

```{python}
from typing import List
import random

class Rappeur:
    """Classe d√©finissant un rappeur caract√©ris√© par son nom, style de flow, nombre 
    d'albums, collaborations et punchlines.
    """
    def __init__(self, nom: str, flow: str, nb_albums: int, featurings: List[str], 
                 punchlines: List[str]):
        self.nom: str = nom
        self.flow: str = flow
        self.nb_albums: int = nb_albums
        self.featurings: List[str] = featurings
        self.punchlines: List[str] = punchlines

    def balancer_punchline(self) -> None:
        """Affiche une punchline al√©atoire du rappeur."""
        punchline: str = random.choice(self.punchlines)
        print(f"{self.nom} balance : {punchline}")

    def clasher(self, autre_rappeur: 'Rappeur') -> None:
        """Permet au rappeur de clasher un autre rappeur en utilisant la premi√®re 
        punchline de sa liste.
        """
        print(f"{self.nom} clash {autre_rappeur.nom} : {self.punchlines[0]}")
        
    def repondre(self, autre_rappeur: 'Rappeur', punchline: str) -> None:
        """Permet au rappeur de r√©pondre √† un clash avec une punchline sp√©cifique."""
        print(f"{self.nom} r√©pond √† {autre_rappeur.nom} : {punchline}")

    def changer_flow(self, nouveau_flow: str) -> None:
        """Change le flow du rappeur."""
        self.flow = nouveau_flow

# Cr√©ation de l'instance de Booba
booba = Rappeur(
    nom="Booba", 
    flow="Agressif et technique",                
    nb_albums=10,
    featurings=["Kaaris", "Damso", "Gato"],
    punchlines=["T'es qu'un fils de...", "J'vais t'faire une Kalash en live"]
)

# Affichage du flow avant la modification
print("Flow avant : ", booba.flow)

# Modification du flow
booba.changer_flow("Po√©tique et introspectif")

# Affichage du flow apr√®s la modification
print("Flow apr√®s : ", booba.flow)
```

::: {.callout-caution}
### Toute variable n'est pas un attribut

L'attribut *nouveau_flow* n'√©tait pas n√©cessaire dans le constructeur de la classe. Pour changer le flow, il est plus appropri√© d'utiliser une m√©thode d√©di√©e. 

*Explication* : Le constructeur d'une classe est g√©n√©ralement utilis√© pour initialiser les attributs qui d√©finissent l'√©tat de base d'une instance. nouveau_flow est plus une action ponctuelle qu'un attribut d'√©tat permanent de l'objet. Avoir un attribut initial pour flow est logique car il d√©crit une propri√©t√© de l'instance de Rappeur. En revanche, nouveau_flow ressemble plus √† une valeur temporaire utilis√©e pour modifier flow.*
:::

En suivant ces √©tapes, tu peux efficacement g√©rer et mettre √† jour les attributs de tes instances de `Rappeur`, ce qui te permet de maintenir ton code organis√© et tes donn√©es √† jour.

Voil√† les gars, vous savez maintenant comment g√©rer les attributs de vos rappeurs comme des pros ! 

**Maintenant TIME TO PRACTICE ! üí™**

## Exercices 

Je t'ai concoct√© une s√©rie d'exercices passionnants üåü qui te permettront non seulement de cr√©er de nouvelles classes, mais aussi de (re)d√©couvrir des notions essentielles de la programmation Python üêç. 

Ces exercices sont sp√©cialement con√ßus pour booster ta compr√©hension des principes de la programmation orient√©e objet üîÑ, tout en te donnant l'occasion de manipuler des attributs, de g√©rer des m√©thodes, et d'explorer des interactions complexes entre objets. 

Bonne courage et surtout, prends du plaisir en codant ! üöÄ‚ú®

### Facile : Cr√©ation de la classe `Rappeur`
#### √ânonc√©
Cr√©e une classe `Rappeur` avec les attributs suivants :

* `nom` : le nom du rappeur.

* `flow` : une description du style de flow du rappeur.

* `albums` : une liste des noms d'albums du rappeur.

La classe doit aussi inclure une m√©thode `introduction()` qui affiche une phrase d√©crivant le rappeur et une m√©thode `sortir_album()` qui prend le nom d'un nouvel album et l'ajoute √† la liste des albums.

::: {.callout-tip}
## Conseil
Pour la m√©thode sortir_album(), assure-toi de v√©rifier que l'album n'est pas d√©j√† dans la liste avant de l'ajouter. Cela √©vitera les doublons dans la discographie du rappeur.
:::

### Facile : La Biblioth√®que 
#### √ânonc√©
Cr√©e une classe `Livre` avec les attributs suivants :

* `titre` : le titre du livre.

* `auteur` : l'auteur du livre.

La classe doit inclure des m√©thodes pour :

* D√©finir un premier livre num√©rique et afficher ses informations.

* Mettre √† jour le titre et l'auteur d'un livre.

* Afficher les d√©tails d'un livre.

::: {.callout-tip}
## Conseil
Lorsque tu modifies les attributs d'un livre, pense √† utiliser des m√©thodes de getter et de setter. Cela te permet de contr√¥ler comment les attributs sont mis √† jour et de valider les donn√©es si n√©cessaire.
:::

### Facile : Compte bancaire
#### √ânonc√©
Cr√©e une classe `Account` avec les attributs suivants :

* `solde` : le solde initial du compte.

La classe doit inclure des m√©thodes pour :

* D√©poser des fonds sur le compte.

* Retirer des fonds du compte.

* Appliquer un taux d'int√©r√™t au solde du compte.

::: {.callout-tip}
## Conseil
Teste scrupuleusement les m√©thodes de d√©p√¥t et de retrait pour g√©rer correctement les sc√©narios o√π le compte pourrait devenir n√©gatif. Ajoute des conditions pour emp√™cher le retrait de fonds sup√©rieurs au solde disponible.
:::

### Interm√©diaire : Conseiller financier 
#### √ânonc√©
Cr√©e une classe `CompteBancaire` avec les attributs suivants :

* `identifiant` : l'identifiant du compte.

* `nom_proprietaire` : le nom du propri√©taire du compte.

* `solde` : le solde initial du compte.

La classe doit inclure des m√©thodes pour :

* G√©rer les d√©p√¥ts et les retraits, en appliquant des agios en cas de d√©couvert.

* Afficher tous les d√©tails du compte.

::: {.callout-tip}
## Conseil
Pour g√©rer les d√©couverts, envisage d'ajouter un attribut qui d√©finit un d√©couvert maximum autoris√©. Cela rendra la gestion du compte plus flexible et r√©aliste.
:::

### Interm√©diaire : Gestion des Featurings
#### √ânonc√©
Am√©liore la classe `Rappeur` pour inclure un attribut `collaborations`, qui est une liste de tuples. Chaque tuple contient le nom d'un autre rappeur et le titre de la chanson sur laquelle ils ont collabor√©.

La classe doit inclure des m√©thodes pour :

* Ajouter une collaboration √† la liste des collaborations.

* Afficher toutes les collaborations du rappeur.

::: {.callout-tip}
## Conseil
Quand tu ajoutes des collaborations, assure-toi de v√©rifier si la collaboration existe d√©j√† pour √©viter les entr√©es en double. Cela peut √™tre fait en v√©rifiant si le tuple (rappeur, titre de la chanson) est d√©j√† dans la liste des collaborations.
:::

### Difficile : Tournoi de Bataille
#### √ânonc√©
Cr√©e une classe `Carte` avec les attributs suivants :

* `valeur` : la valeur de la carte.

* `nom` : le nom de la carte.

Cr√©e une classe `Paquet` avec les attributs suivants :

* `cartes` : la liste des cartes du paquet.

La classe `Paquet` doit inclure des m√©thodes pour :

* M√©langer le paquet de cartes.

* Distribuer les cartes √©quitablement entre les joueurs.

Cr√©e une classe `Joueur` avec les attributs suivants :

* `main` : la main du joueur.

La classe `Joueur` doit inclure des m√©thodes pour :

* Pr√©parer la main du joueur pour la bataille.

Cr√©e une classe `Tournoi` avec les attributs suivants :

* `joueurs` : la liste des joueurs participants.

La classe `Tournoi` doit inclure des m√©thodes pour :

* D√©rouler la bataille entre les joueurs.

* D√©clarer le gagnant du tournoi.

::: {.callout-tip}
## Conseil
Pour la distribution des cartes, assure-toi que le m√©lange soit complet avant de distribuer les cartes afin d'assurer l'√©quit√© du jeu. Utilise des m√©thodes robustes pour g√©rer les √©galit√©s et les cas sp√©ciaux o√π plusieurs tours de cartes sont n√©cessaires.
:::

### Difficile : Battle de Rap
#### √ânonc√©
Cr√©e une classe `Battle` avec les attributs suivants :
* `rappeur1` : le premier rappeur participant.
* `rappeur2` : le deuxi√®me rappeur participant.

La classe `Battle` doit inclure des m√©thodes pour :
* Faire s'affronter les deux rappeurs en affichant leurs punchlines et d√©terminer le gagnant.
* Afficher le gagnant de la bataille et sa punchline gagnante.

**Bonus** : Impl√©mente une m√©thode `juger_punchline(punchline)` dans la classe `Rappeur` qui attribue un score √† une punchline bas√© sur des crit√®res comme la rime, le nombre de syllabes, ou d'autres aspects stylistiques que tu juges importants.

::: {.callout-tip}
## Conseil
Dans la m√©thode `juger_punchline(punchline)`, consid√®re d'utiliser des techniques d'analyse de texte pour √©valuer les punchlines, comme compter les syllabes ou utiliser des expressions r√©guli√®res pour identifier les rimes et autres figures de style.
:::

## Correction 

La correction sera disponible prochainement ;)

-----------------

::: {.cours-btn}
[Plus de cours](index.qmd)
:::

::: {.further-info}
::: grid
::: {.g-col-12 .g-col-md-12}
√Ä propos des auteurs
: M√©nyssa Cherifa-Luron, PhD est data scientist et formatrice freelance.
:::

::: {.g-col-12 .g-col-md-6}
Copyright and licence
: &copy; 2024, M√©nyssa Cherifa-Luron

<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" style="height:22px!important;vertical-align:text-bottom;"/><img src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"/><img src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"/></a> Ce cours est sous licence Creative Commons Attribution-NonCommercial 4.0 (CC BY-NC 4.0) <a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> International licence</a>.


:::

::: {.g-col-12 .g-col-md-6}
Citer ce cours :
: M√©nyssa Cherifa-Luron. "Gentle introduction √† la Programmation Orient√©e Objets en Python". DAMA, 23/05/2024. Disponible [ici]( https://universdesdonnees.github.io/dama/cours/python_poo.html)
:::
:::
:::